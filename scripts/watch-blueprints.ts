import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { createHash } from "node:crypto";

import { watch } from "chokidar";
import type { FSWatcher } from "chokidar";

import { blueprintSlug } from "../app/lib/blueprints";

type BlueprintEntry = {
  slug: string;
  importName: string;
  importPath: string;
  absolutePath: string;
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT_DIR = path.resolve(__dirname, "..");
const GAMES_DIR = path.join(ROOT_DIR, "app", "games");
const INDEX_PATH = path.join(GAMES_DIR, "blueprint-manifest-index.ts");

const environment = process.env.NODE_ENV ?? "development";
const runOnce = process.argv.includes("--once");
const shouldWatch = environment === "development" && !runOnce;

async function pathExists(targetPath: string) {
  try {
    await fs.access(targetPath);
    return true;
  } catch {
    return false;
  }
}

async function discoverGameDirectories() {
  const entries = await fs.readdir(GAMES_DIR, { withFileTypes: true });
  const games: string[] = [];

  for (const entry of entries) {
    if (!entry.isDirectory()) continue;
    const gamePath = path.join(GAMES_DIR, entry.name);
    const hasGameFile = await pathExists(path.join(gamePath, "game.json"));
    const hasBlueprintDir = await pathExists(path.join(gamePath, "blueprints"));

    if (hasGameFile && hasBlueprintDir) {
      games.push(entry.name);
    }
  }

  return games;
}

const gameValidityCache = new Map<string, boolean>();

async function isValidGame(game: string) {
  if (gameValidityCache.has(game)) {
    return gameValidityCache.get(game) ?? false;
  }

  const gamePath = path.join(GAMES_DIR, game);
  const hasGameFile = await pathExists(path.join(gamePath, "game.json"));
  const hasBlueprintDir = await pathExists(path.join(gamePath, "blueprints"));
  const isValid = hasGameFile && hasBlueprintDir;

  gameValidityCache.set(game, isValid);

  return isValid;
}

async function listBlueprintEntries(game: string): Promise<BlueprintEntry[]> {
  const blueprintDir = path.join(GAMES_DIR, game, "blueprints");

  try {
    const files = await fs.readdir(blueprintDir, { withFileTypes: true });

    const entries = files
      .filter(
        (file) =>
          file.isFile() &&
          file.name.endsWith(".ts") &&
          !file.name.endsWith(".d.ts")
      )
      .map((file) => {
        const baseName = path.parse(file.name).name;
        const slug = blueprintSlug(baseName);
        return {
          slug,
          importName: toIdentifier(slug),
          importPath: `./blueprints/${baseName}`,
          absolutePath: path.join(blueprintDir, file.name),
        } satisfies BlueprintEntry;
      })
      .sort((a, b) => a.slug.localeCompare(b.slug));

    return entries;
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === "ENOENT") {
      return [];
    }
    throw error;
  }
}

function toIdentifier(slug: string) {
  const parts = slug
    .split(/[^a-zA-Z0-9]+/)
    .filter(Boolean)
    .map((part, index) =>
      index === 0
        ? part.toLowerCase()
        : part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
    );

  const candidate = parts.join("") || "blueprint";
  const safeStart = /[a-zA-Z_$]/.test(candidate.charAt(0))
    ? candidate
    : `_${candidate}`;

  return safeStart;
}

function buildManifestContent(
  entries: BlueprintEntry[],
  game: string,
  hash: string
) {
  const lines = [
    `// Auto-generated for ${game}. Do not edit by hand.`,
    "// Generated by scripts/watch-blueprints.ts",
  ];

  if (entries.length > 0) {
    lines.push("", ...entries.map(toImportStatement));
  }

  lines.push("", "export const blueprints = {");

  for (const entry of entries) {
    lines.push(`  "${entry.slug}": ${entry.importName},`);
  }

  lines.push("};");
  lines.push("", `export const manifestVersion = "${hash}";`, "");

  lines.push(
    "if (typeof module !== \"undefined\" && (module as any).hot) {",
    "  (module as any).hot.accept();",
    "}",
    ""
  );

  lines.push(
    "if (typeof window !== \"undefined\") {",
    `  window.dispatchEvent(new CustomEvent("blueprint-manifest-updated", { detail: { game: "${game}", version: manifestVersion } }));`,
    "}",
    ""
  );

  return `${lines.join("\n")}`;
}

async function hashBlueprints(entries: BlueprintEntry[]) {
  const hash = createHash("sha1");

  for (const entry of entries) {
    hash.update(entry.slug);
    hash.update("|");
    try {
      const content = await fs.readFile(entry.absolutePath, "utf8");
      hash.update(content);
    } catch {
      // ignore missing files
    }
    hash.update("|");
  }

  return hash.digest("hex");
}

function toImportStatement(entry: BlueprintEntry) {
  return `import * as ${entry.importName} from "${entry.importPath}";`;
}

async function writeIfChanged(filePath: string, content: string) {
  try {
    const existing = await fs.readFile(filePath, "utf8");
    if (existing === content) {
      return false;
    }
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
      throw error;
    }
  }

  await fs.writeFile(filePath, content, "utf8");
  return true;
}

async function generateManifest(game: string) {
  const entries = await listBlueprintEntries(game);
  const manifestPath = path.join(GAMES_DIR, game, "blueprint-manifest.ts");
  const hash = await hashBlueprints(entries);
  const content = buildManifestContent(entries, game, hash);
  const didWrite = await writeIfChanged(manifestPath, content);

  if (didWrite) {
    console.log(
      `watch-blueprints: updated ${path.relative(ROOT_DIR, manifestPath)}`
    );
  }
}

async function generateIndex(games: string[]) {
  const sortedGames = [...games].sort((a, b) => a.localeCompare(b));
  const lines = [
    "// Auto-generated. Do not edit by hand.",
    "// Generated by scripts/watch-blueprints.ts",
  ];

  for (const game of sortedGames) {
    const identifier = toIdentifier(game);
    lines.push(
      `import * as ${identifier} from "./${game}/blueprint-manifest";`
    );
  }

  lines.push(
    "",
    "export const blueprintManifests: Record<string, unknown> = {"
  );
  for (const game of sortedGames) {
    const identifier = toIdentifier(game);
    lines.push(`  "${game}": ${identifier},`);
  }
  lines.push("};");

  lines.push(
    "",
    "export function getBlueprintManifestVersion(game: string): string | null {"
  );
  lines.push(
    "  const manifest = (blueprintManifests as Record<string, { manifestVersion?: string }>)[game];"
  );
  lines.push("  return manifest?.manifestVersion ?? null;", "}", "");

  lines.push(
    "if (typeof module !== \"undefined\" && (module as any).hot) {",
    "  (module as any).hot.accept();",
    "}",
    ""
  );

  const content = lines.join("\n");
  const didWrite = await writeIfChanged(INDEX_PATH, content);
  if (didWrite) {
    console.log(
      `watch-blueprints: updated ${path.relative(ROOT_DIR, INDEX_PATH)}`
    );
  }
}

function watchGames(games: string[]) {
  const watcher: FSWatcher = watch(
    path.join(GAMES_DIR, "*", "blueprints", "*.ts"),
    {
      ignoreInitial: true,
    }
  );

  const timers = new Map<string, NodeJS.Timeout>();

  const schedule = (game: string) => {
    if (!game) return;
    const existing = timers.get(game);
    if (existing) {
      clearTimeout(existing);
    }

    const handle = setTimeout(() => {
      timers.delete(game);
      void generateManifest(game);
    }, 50);

    timers.set(game, handle);
  };

  const queueIfValid = (targetPath: string) => {
    const game = gameFromPath(targetPath);
    if (!game) return;

    void isValidGame(game).then((valid) => {
      if (valid) {
        schedule(game);
        void generateIndex(games);
      }
    });
  };

  watcher.on("add", queueIfValid);
  watcher.on("change", queueIfValid);
  watcher.on("unlink", queueIfValid);
  watcher.on("addDir", queueIfValid);
  watcher.on("ready", () => {
    console.log("watch-blueprints: watching for blueprint changes...");
  });

  const closeWatcher = async () => {
    timers.forEach((timer) => clearTimeout(timer));
    await watcher.close();
  };

  process.on("SIGINT", () => {
    void closeWatcher().then(() => process.exit(0));
  });
  process.on("SIGTERM", () => {
    void closeWatcher().then(() => process.exit(0));
  });
}

function gameFromPath(targetPath: string) {
  const relative = path.relative(GAMES_DIR, targetPath);
  const [game] = relative.split(path.sep);
  return game;
}

async function main() {
  const games = await discoverGameDirectories();

  await Promise.all(games.map((game) => generateManifest(game)));
  await generateIndex(games);

  if (games.length === 0) {
    console.warn("watch-blueprints: no games found under app/games");
    return;
  }

  if (!shouldWatch) {
    console.log(
      `watch-blueprints: generation finished (watch disabled, NODE_ENV=${environment})`
    );
    return;
  }

  watchGames(games);
}

main().catch((error) => {
  console.error("watch-blueprints: failed", error);
  process.exit(1);
});
